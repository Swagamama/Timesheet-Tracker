async parseRosterText(textContent) {
                console.log('Starting PDF parsing...');
                
                const fullText = textContent.items.map(item => item.str).join(' ');
                
                // Find week ending date
                const weekEndingMatch = fullText.match(/Week ending (\d{2}\/\d{2}\/\d{4})/);
                if (!weekEndingMatch) {
                    console.log('No week ending found');
                    return null;
                }
                const weekEnding = weekEndingMatch[1];
                console.log('Found week ending:', weekEnding);

                // Check if Rohan is in the PDF
                if (!fullText.toLowerCase().includes('rohan')) {
                    console.log('Rohan not found in PDF');
                    return null;
                }

                const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                const schedule = {};

                // Find dates in the text
                const datePattern = /(\d{2}[./-]\d{2}[./-]\d{4})/g;
                const dates = fullText.match(datePattern);
                console.log('Found dates:', dates);

                if (dates && dates.length >= 5) {
                    days.forEach((day, index) => {
                        schedule[day] = {
                            date: dates[index] ? dates[index].replace(/-/g, '.').replace(/\//g, '.') : '',
                            shifts: []
                        };
                    });
                }

                // Extract words with positions (simulating pdfplumber's extract_words)
                const words = textContent.items.map(item => ({
                    text: item.str,
                    x0: item.transform[4],
                    x1: item.transform[4] + (item.width || 0),
                    top: item.transform[5],
                    bottom: item.transform[5] - (item.height || 0)
                }));

                console.log(`Extracted ${words.length} words`);

                // Find column boundaries from weekday headers
                const colBounds = this.getColumnBounds(words);
                if (!colBounds) {
                    console.log('Could not determine column boundaries');
                    return null;
                }
                console.log('Column boundaries:', colBounds);

                // Group words by Y coordinate (rows)
                const rows = {};
                words.forEach(word => {
                    if (days.includes(word.text)) return; // Skip weekday headers
                    
                    const yKey = Math.round(word.top);
                    if (!rows[yKey]) rows[yKey] = [];
                    rows[yKey].push(word);
                });

                // Sort rows by Y coordinate (top to bottom)
                const rowKeys = Object.keys(rows).map(Number).sort((a, b) => b - a);

                // Create grid structure
                const grid = [];
                rowKeys.forEach(y => {
                    const cells = ['', '', '', '', ''];
                    rows[y].forEach(word => {
                        const xCenter = (word.x0 + word.x1) / 2;
                        const colIndex = this.getColumnIndex(colBounds, xCenter);
                        if (colIndex !== null) {
                            cells[colIndex] = (cells[colIndex] + ' ' + word.text).trim();
                        }
                    });
                    grid.push(cells);
                });

                console.log(`Created grid with ${grid.length} rows`);

                // Parse the grid for Rohan's schedule
                let lastTimeStarts = null;
                const captures = { Monday: [], Tuesday: [], Wednesday: [], Thursday: [], Friday: [] };
                const notes = { Monday: [], Tuesday: [], Wednesday: [], Thursday: [], Friday: [] };

                grid.forEach((cells, rowIndex) => {
                    // Check if this is a time row
                    if (this.isTimeRow(cells)) {
                        lastTimeStarts = this.getTimeStarts(cells);
                        console.log(`Row ${rowIndex} is time row:`, lastTimeStarts);
                        return;
                    }

                    // Check for Rohan in this row
                    if (lastTimeStarts) {
                        cells.forEach((cell, dayIndex) => {
                            const cellText = (cell || '').trim();
                            if (cellText && cellText.toLowerCase().includes('rohan')) {
                                const day = days[dayIndex];
                                const startTime = lastTimeStarts[dayIndex];
                                
                                console.log(`Found Rohan in ${day}: '${cellText}' with time ${startTime}`);
                                
                                if (startTime) {
                                    captures[day].push(startTime);
                                }
                                
                                if (cellText.toUpperCase().includes('ATM')) {
                                    notes[day].push('ATM');
                                }
                            }
                        });
                    }
                });

                console.log('Captures:', captures);
                console.log('Notes:', notes);

                // Build final schedule
                days.forEach((day, index) => {
                    const starts = captures[day];
                    let chosen = null;
                    
                    if (starts && starts.length > 0) {
                        // Choose the latest start time if multiple found
                        const timeToMinutes = (timeStr) => {
                            const [hours, minutes] = timeStr.split(':').map(Number);
                            return hours * 60 + minutes;
                        };
                        
                        chosen = starts.sort((a, b) => timeToMinutes(a) - timeToMinutes(b))[starts.length - 1];
                    }

                    const dayNotes = notes[day];
                    const note = dayNotes && dayNotes.length > 0 ? [...new Set(dayNotes)].join(', ') : '';

                    if (chosen) {
                        // We need to determine the section and end time
                        // For now, we'll set a default end time and section
                        schedule[day].shifts.push({
                            startTime: chosen,
                            endTime: this.getEndTimeForStart(chosen), // Helper function
                            section: this.getSectionForTime(chosen), // Helper function  
                            note: note
                        });
                    }
                });

                console.log('Final schedule:', schedule);

                // Check if we found any shifts
                const hasShifts = days.some(day => 
                    schedule[day] && schedule[day].shifts && schedule[day].shifts.length > 0
                );

                if (!hasShifts) {
                    console.log('No shifts found for Rohan');
                    return null;
                }

                return {
                    weekEnding,
                    schedule,
                    uploadDate: new Date().toISOString()
                };
            }

            getColumnBounds(words) {
                const weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                const headers = {};
                
                words.forEach(word => {
                    if (weekdays.includes(word.text) && !headers[word.text]) {
                        headers[word.text] = {
                            x0: word.x0,
                            x1: word.x1,
                            center: (word.x0 + word.x1) / 2
                        };
                    }
                });

                if (Object.keys(headers).length < 5) {
                    return null;
                }

                // Sort by center position
                const sortedHeaders = weekdays
                    .filter(day => headers[day])
                    .map(day => ({ day, center: headers[day].center }))
                    .sort((a, b) => a.center - b.center);

                const centers = sortedHeaders.map(h => h.center);
                const boundaries = [];
                
                for (let i = 0; i < centers.length - 1; i++) {
                    boundaries.push((centers[i] + centers[i + 1]) / 2);
                }

                const leftBound = centers[0] - (boundaries[0] - centers[0]);
                const rightBound = centers[centers.length - 1] + (centers[centers.length - 1] - boundaries[boundaries.length - 1]);

                return [leftBound, ...boundaries, rightBound];
            }

            getColumnIndex(colBounds, xCenter) {
                for (let i = 0; i < 5; i++) {
                    if (colBounds[i] <= xCenter && xCenter < colBounds[i + 1]) {
                        return i;
                    }
                }
                return null;
            }

            isTimeRow(cells) {
                const timePattern = /(\d{1,2}:\d{2})\s*-\s*\d{1,2}:\d{2}/;
                let timeCount = 0;
                
                cells.forEach(cell => {
                    if (timePattern.test(cell || '')) {
                        timeCount++;
                    }
                });
                
                return timeCount >= 3;
            }

            getTimeStarts(cells) {
                const timePattern = /(\d{1,2}:\d{2})\s*-\s*\d{1,2}:\d{2}/;
                return cells.map(cell => {
                    const match = (cell || '').match(timePattern);
                    return match ? match[1] : null;
                });
            }

            getEndTimeForStart(startTime) {
                // Common end times based on start times - you can customize this
                const commonPairs = {
                    '6:00': '12:00',
                    '6:30': '15:30', 
                    '7:00': '13:00',
                    '9:30': '18:00',
                    '10:30': '16:30',
                    '11:30': '17:30'
                };
                
                return commonPairs[startTime] || '17:00';
            }

            getSectionForTime(startTime) {
                // You can customize this based on common patterns
                const timeToSection = {
                    '6:00': 'Batching',
                    '6:30': 'Batching',
                    '7:00': 'Batching', 
                    '9:30': 'ATM/Processing',
                    '10:30': 'ATM/ Processing office',
                    '11:30': 'ATM/Processing'
                };
                
                return timeToSection[startTime] || 'General';
            }<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roster Tracker - Rohan</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #fff;
            color: #333;
            padding: 30px;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .header p {
            color: #666;
            font-size: 1rem;
        }

        .controls {
            padding: 30px;
            background: #fafafa;
            border-bottom: 1px solid #e0e0e0;
        }

        .file-upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            margin-bottom: 20px;
        }

        .file-upload-area:hover {
            background: #f8f8f8;
            border-color: #999;
        }

        .file-upload-area.dragging {
            background: #f0f0f0;
            border-color: #666;
        }

        #fileInput {
            display: none;
        }

        .upload-text {
            font-weight: 500;
            margin-bottom: 5px;
        }

        .upload-subtext {
            font-size: 0.9rem;
            color: #666;
        }

        .dropdown-container {
            position: relative;
            margin-bottom: 20px;
        }

        #weekSelector {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
        }

        #weekSelector:focus {
            outline: none;
            border-color: #666;
        }

        .schedule-display {
            padding: 30px;
        }

        .week-info {
            background: #f8f8f8;
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 25px;
            border-left: 4px solid #333;
        }

        .week-info h3 {
            color: #333;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .week-info p {
            color: #666;
            font-size: 0.9rem;
        }

        .day-schedule {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .day-schedule:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .day-label {
            font-weight: 600;
            color: #333;
            min-width: 100px;
            font-size: 1rem;
        }

        .time-display {
            font-size: 1rem;
            font-weight: 500;
            color: #333;
            min-width: 120px;
            font-family: monospace;
        }

        .section-badge {
            background: #333;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .note-badge {
            background: #f0f0f0;
            color: #666;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            border: 1px solid #ddd;
        }

        .off-day {
            background: #f9f9f9;
            color: #999;
        }

        .off-day .day-label {
            color: #999;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #666;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            padding: 60px 30px;
            color: #666;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .status-message {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
        }

        .status-message.success {
            background: #e8f5e8;
            color: #2d5016;
            border: 1px solid #c3e6c3;
            display: block;
        }

        .status-message.error {
            background: #f8e8e8;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.5rem;
            }
            
            .day-schedule {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .container {
                border-radius: 0;
                margin: 0 -20px;
            }
            
            body {
                padding: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Roster Tracker</h1>
            <p>Track your work schedule</p>
        </div>

        <div class="controls">
            <div class="file-upload-area" id="uploadArea">
                <div class="upload-text">Upload PDF Roster</div>
                <div class="upload-subtext">Click here or drag and drop your roster file</div>
                <input type="file" id="fileInput" accept=".pdf">
            </div>

            <div id="statusMessage" class="status-message"></div>

            <div class="dropdown-container">
                <select id="weekSelector">
                    <option value="">Select a week...</option>
                </select>
            </div>
        </div>

        <div class="schedule-display" id="scheduleDisplay">
            <div class="empty-state">
                <h3>No roster selected</h3>
                <p>Upload a PDF roster or select a week from the dropdown to view your schedule</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script>
        // Set worker source for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        class RosterTracker {
            constructor() {
                this.tempStorage = {}; // Initialize temp storage
                this.rosters = this.loadFromStorage();
                this.currentWeek = null;
                this.userName = 'Rohan';
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.cleanOldRosters();
                this.populateWeekSelector();
                this.checkCurrentWeek();
            }

            setupEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const weekSelector = document.getElementById('weekSelector');

                uploadArea.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
                weekSelector.addEventListener('change', (e) => this.displayWeek(e.target.value));

                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragging');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragging');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragging');
                    if (e.dataTransfer.files[0]) {
                        this.processFile(e.dataTransfer.files[0]);
                    }
                });
            }

            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (file && file.type === 'application/pdf') {
                    await this.processFile(file);
                } else {
                    this.showStatus('Please upload a valid PDF file', 'error');
                }
            }

            async processFile(file) {
                this.showLoading();
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                    const page = await pdf.getPage(1);
                    const textContent = await page.getTextContent();
                    
                    const rosterData = this.parseRosterText(textContent);
                    if (rosterData) {
                        this.saveRoster(rosterData);
                        this.populateWeekSelector();
                        this.displayWeek(rosterData.weekEnding);
                        this.showStatus('Roster uploaded successfully', 'success');
                    } else {
                        this.showStatus('Could not find your schedule in this roster', 'error');
                    }
                } catch (error) {
                    console.error('Error processing PDF:', error);
                    this.showStatus('Error processing PDF file', 'error');
                }
            }

            parseRosterText(textContent) {
                const items = textContent.items.map(item => item.str);
                const fullText = items.join(' ');
                
                console.log('Full PDF text:', fullText);
                
                // Find week ending date
                const weekEndingMatch = fullText.match(/Week ending (\d{2}\/\d{2}\/\d{4})/);
                if (!weekEndingMatch) {
                    console.log('No week ending found');
                    return null;
                }
                const weekEnding = weekEndingMatch[1];
                console.log('Found week ending:', weekEnding);

                // Initialize schedule structure
                const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                const schedule = {};
                
                // Find dates for each day
                const datePattern = /(\d{2}\.\d{2}\.\d{4})/g;
                const dates = fullText.match(datePattern);
                console.log('Found dates:', dates);
                
                if (dates && dates.length >= 5) {
                    days.forEach((day, index) => {
                        schedule[day] = {
                            date: dates[index],
                            shifts: []
                        };
                    });
                }

                // Parse using a different approach - look for patterns in the text
                // The PDF structure has sections followed by time slots and names
                
                // Split by common section headers to process each section
                const sections = [
                    'ATM/ Processing office',
                    'Packer/CP',
                    'Batching', 
                    'ATM/Processing',
                    'Dispatch'
                ];
                
                let currentPos = 0;
                
                sections.forEach(sectionName => {
                    const sectionIndex = fullText.indexOf(sectionName, currentPos);
                    if (sectionIndex === -1) return;
                    
                    // Find the next section or end of document
                    let nextSectionIndex = fullText.length;
                    for (let otherSection of sections) {
                        if (otherSection === sectionName) continue;
                        const otherIndex = fullText.indexOf(otherSection, sectionIndex + 1);
                        if (otherIndex !== -1 && otherIndex < nextSectionIndex) {
                            nextSectionIndex = otherIndex;
                        }
                    }
                    
                    // Check for "Leave" section too
                    const leaveIndex = fullText.indexOf('Leave', sectionIndex + 1);
                    if (leaveIndex !== -1 && leaveIndex < nextSectionIndex) {
                        nextSectionIndex = leaveIndex;
                    }
                    
                    const sectionText = fullText.substring(sectionIndex, nextSectionIndex);
                    console.log(`\n--- Processing section: ${sectionName} ---`);
                    console.log('Section text:', sectionText);
                    
                    this.parseSection(sectionText, sectionName, schedule, days);
                    currentPos = nextSectionIndex;
                });

                console.log('Final schedule:', schedule);
                
                // Check if we found any shifts for Rohan
                const hasShifts = days.some(day => schedule[day] && schedule[day].shifts && schedule[day].shifts.length > 0);
                
                if (!hasShifts) {
                    console.log('No shifts found for Rohan, parsing failed');
                    return null;
                }

                return {
                    weekEnding,
                    schedule,
                    uploadDate: new Date().toISOString()
                };
            }

            parseSection(sectionText, sectionName, schedule, days) {
                // Find all time slots in this section
                const timeSlots = [];
                const timeRegex = /(\d{1,2}:\d{2})-(\d{1,2}:\d{2})/g;
                let match;
                
                while ((match = timeRegex.exec(sectionText)) !== null) {
                    timeSlots.push({
                        fullTime: match[0],
                        startTime: match[1],
                        endTime: match[2],
                        index: match.index
                    });
                }
                
                console.log(`Found ${timeSlots.length} time slots in ${sectionName}:`, timeSlots.map(t => t.fullTime));
                
                // For each time slot, look for Rohan entries
                timeSlots.forEach(timeSlot => {
                    // Get text after this time slot until the next time slot or end of section
                    let endIndex = sectionText.length;
                    const nextTimeSlot = timeSlots.find(t => t.index > timeSlot.index);
                    if (nextTimeSlot) {
                        endIndex = nextTimeSlot.index;
                    }
                    
                    const timeSlotText = sectionText.substring(timeSlot.index, endIndex);
                    console.log(`\nTime slot ${timeSlot.fullTime} text:`, timeSlotText);
                    
                    // Look for Rohan in this time slot's text
                    if (timeSlotText.includes('Rohan')) {
                        console.log(`Found Rohan in ${timeSlot.fullTime}!`);
                        
                        // Extract note if present
                        const noteMatch = timeSlotText.match(/Rohan\s*\(([^)]+)\)/);
                        const note = noteMatch ? noteMatch[1] : '';
                        
                        // Determine which day(s) based on position analysis
                        const rohanDays = this.determineDaysForRohan(timeSlotText, sectionText, days);
                        
                        rohanDays.forEach(day => {
                            console.log(`Adding ${day}: ${timeSlot.startTime}-${timeSlot.endTime} (${sectionName}${note ? ', ' + note : ''})`);
                            schedule[day].shifts.push({
                                startTime: timeSlot.startTime,
                                endTime: timeSlot.endTime,
                                section: sectionName,
                                note: note
                            });
                        });
                    }
                });
            }

            determineDaysForRohan(timeSlotText, sectionText, days) {
                // This is a simplified approach - we'll analyze the position of Rohan
                // relative to other known patterns
                
                // For now, let's use a heuristic based on the text structure
                // In your example, we know the pattern, so let's implement the specific logic
                
                const rohanIndex = timeSlotText.indexOf('Rohan');
                const beforeRohan = timeSlotText.substring(0, rohanIndex);
                const afterRohan = timeSlotText.substring(rohanIndex);
                
                // Count spaces or patterns that might indicate column position
                // This is a rough heuristic - in a real parser, we'd use coordinates
                
                const words = beforeRohan.split(/\s+/).filter(w => w.length > 0);
                const nameWords = words.filter(w => /^[A-Z][a-z]+/.test(w) && !w.match(/\d/));
                
                console.log('Words before Rohan:', words);
                console.log('Name words before Rohan:', nameWords);
                
                // Simple heuristic: assume column based on number of names before Rohan
                const columnIndex = Math.min(nameWords.length, 4);
                
                if (columnIndex >= 0 && columnIndex < days.length) {
                    return [days[columnIndex]];
                }
                
                // Fallback: try all days (this will be corrected by manual verification)
                return days;
            }

            findDayColumn(nameLine, allLines, currentIndex) {
                // This function attempts to determine which day column a name appears in
                // by analyzing the position and context
                
                // Look for day headers above this position
                for (let i = currentIndex - 1; i >= Math.max(0, currentIndex - 20); i--) {
                    const line = allLines[i];
                    if (line.includes('Monday')) return 0;
                    if (line.includes('Tuesday')) return 1;
                    if (line.includes('Wednesday')) return 2;
                    if (line.includes('Thursday')) return 3;
                    if (line.includes('Friday')) return 4;
                }
                
                // If we can't determine the column, return -1
                return -1;
            }

            saveRoster(rosterData) {
                this.rosters[rosterData.weekEnding] = rosterData;
                this.saveToStorage();
                console.log('Saved roster for week:', rosterData.weekEnding);
                console.log('Total rosters:', Object.keys(this.rosters).length);
            }

            displayWeek(weekEnding) {
                if (!weekEnding) {
                    this.showEmptyState();
                    return;
                }

                const roster = this.rosters[weekEnding];
                if (!roster) {
                    this.showEmptyState();
                    return;
                }

                const display = document.getElementById('scheduleDisplay');
                const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                
                let html = `
                    <div class="week-info">
                        <h3>Week Ending: ${weekEnding}</h3>
                        <p>Schedule for ${this.userName}</p>
                    </div>
                `;

                days.forEach(day => {
                    const dayData = roster.schedule[day];
                    if (dayData && dayData.shifts && dayData.shifts.length > 0) {
                        const shift = dayData.shifts[0]; // Taking first shift if multiple
                        html += `
                            <div class="day-schedule">
                                <div class="day-label">${day}</div>
                                <div class="time-display">${shift.startTime} - ${shift.endTime}</div>
                                <div class="section-badge">${shift.section}</div>
                                ${shift.note ? `<div class="note-badge">${shift.note}</div>` : ''}
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="day-schedule off-day">
                                <div class="day-label">${day}</div>
                                <div class="time-display">Off</div>
                            </div>
                        `;
                    }
                });

                display.innerHTML = html;
            }

            populateWeekSelector() {
                const selector = document.getElementById('weekSelector');
                const currentWeek = this.getCurrentWeek();
                
                let options = '<option value="">Select a week...</option>';
                
                Object.keys(this.rosters)
                    .sort((a, b) => {
                        const dateA = this.parseWeekEnding(a);
                        const dateB = this.parseWeekEnding(b);
                        return dateB - dateA;
                    })
                    .forEach(weekEnding => {
                        const isCurrentWeek = this.isCurrentWeek(weekEnding);
                        options += `
                            <option value="${weekEnding}">
                                Week ending ${weekEnding}
                                ${isCurrentWeek ? ' (Current Week)' : ''}
                            </option>
                        `;
                    });
                
                selector.innerHTML = options;
                
                // Auto-select current week if available
                if (currentWeek) {
                    selector.value = currentWeek;
                }
            }

            parseWeekEnding(weekEndingStr) {
                const parts = weekEndingStr.split('/');
                return new Date(parts[2], parts[1] - 1, parts[0]);
            }

            isCurrentWeek(weekEnding) {
                const weekEndDate = this.parseWeekEnding(weekEnding);
                const today = new Date();
                const diffTime = weekEndDate - today;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                return diffDays >= 0 && diffDays <= 7;
            }

            getCurrentWeek() {
                const today = new Date();
                const weeks = Object.keys(this.rosters);
                
                for (let weekEnding of weeks) {
                    if (this.isCurrentWeek(weekEnding)) {
                        return weekEnding;
                    }
                }
                return null;
            }

            checkCurrentWeek() {
                const currentWeek = this.getCurrentWeek();
                if (currentWeek) {
                    document.getElementById('weekSelector').value = currentWeek;
                    this.displayWeek(currentWeek);
                }
            }

            cleanOldRosters() {
                const fiveWeeksAgo = new Date();
                fiveWeeksAgo.setDate(fiveWeeksAgo.getDate() - 35);
                
                Object.keys(this.rosters).forEach(weekEnding => {
                    const rosterDate = this.parseWeekEnding(weekEnding);
                    if (rosterDate < fiveWeeksAgo) {
                        delete this.rosters[weekEnding];
                    }
                });
                
                this.saveToStorage();
            }

            showEmptyState() {
                document.getElementById('scheduleDisplay').innerHTML = `
                    <div class="empty-state">
                        <h3>No roster selected</h3>
                        <p>Upload a PDF roster or select a week from the dropdown to view your schedule</p>
                    </div>
                `;
            }

            showLoading() {
                document.getElementById('scheduleDisplay').innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Processing roster...</p>
                    </div>
                `;
            }

            showStatus(message, type) {
                const statusEl = document.getElementById('statusMessage');
                statusEl.textContent = message;
                statusEl.className = `status-message ${type}`;
                
                setTimeout(() => {
                    statusEl.className = 'status-message';
                }, 3000);
            }

            saveToStorage() {
                // Using in-memory storage only since localStorage is not supported
                // Data will persist during the session
                this.tempStorage = { ...this.rosters };
            }

            loadFromStorage() {
                // Return existing temp storage or empty object
                return this.tempStorage || {};
            }
        }

        // Initialize the app
        const app = new RosterTracker();
    </script>
</body>
</html>
