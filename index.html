<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roster Tracker - Rohan</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #fff;
            color: #333;
            padding: 30px;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .header p {
            color: #666;
            font-size: 1rem;
        }

        .controls {
            padding: 30px;
            background: #fafafa;
            border-bottom: 1px solid #e0e0e0;
        }

        .file-upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            margin-bottom: 20px;
        }

        .file-upload-area:hover {
            background: #f8f8f8;
            border-color: #999;
        }

        .file-upload-area.dragging {
            background: #f0f0f0;
            border-color: #666;
        }

        #fileInput {
            display: none;
        }

        .upload-text {
            font-weight: 500;
            margin-bottom: 5px;
        }

        .upload-subtext {
            font-size: 0.9rem;
            color: #666;
        }

        .dropdown-container {
            position: relative;
            margin-bottom: 20px;
        }

        #weekSelector {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
        }

        #weekSelector:focus {
            outline: none;
            border-color: #666;
        }

        .schedule-display {
            padding: 30px;
        }

        .week-info {
            background: #f8f8f8;
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 25px;
            border-left: 4px solid #333;
        }

        .week-info h3 {
            color: #333;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .week-info p {
            color: #666;
            font-size: 0.9rem;
        }

        .day-schedule {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .day-schedule:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .day-label {
            font-weight: 600;
            color: #333;
            min-width: 100px;
            font-size: 1rem;
        }

        .time-display {
            font-size: 1rem;
            font-weight: 500;
            color: #333;
            min-width: 120px;
            font-family: monospace;
        }

        .section-badge {
            background: #333;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .note-badge {
            background: #f0f0f0;
            color: #666;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            border: 1px solid #ddd;
        }

        .off-day {
            background: #f9f9f9;
            color: #999;
        }

        .off-day .day-label {
            color: #999;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #666;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            padding: 60px 30px;
            color: #666;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .status-message {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
        }

        .status-message.success {
            background: #e8f5e8;
            color: #2d5016;
            border: 1px solid #c3e6c3;
            display: block;
        }

        .status-message.error {
            background: #f8e8e8;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.5rem;
            }
            
            .day-schedule {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .container {
                border-radius: 0;
                margin: 0 -20px;
            }
            
            body {
                padding: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Roster Tracker</h1>
            <p>Track your work schedule</p>
        </div>

        <div class="controls">
            <div class="file-upload-area" id="uploadArea">
                <div class="upload-text">Upload PDF Roster</div>
                <div class="upload-subtext">Click here or drag and drop your roster file</div>
                <input type="file" id="fileInput" accept=".pdf">
            </div>

            <div id="statusMessage" class="status-message"></div>

            <div class="dropdown-container">
                <select id="weekSelector">
                    <option value="">Select a week...</option>
                </select>
            </div>
        </div>

        <div class="schedule-display" id="scheduleDisplay">
            <div class="empty-state">
                <h3>No roster selected</h3>
                <p>Upload a PDF roster or select a week from the dropdown to view your schedule</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script>
        // Set worker source for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        class RosterTracker {
            constructor() {
                this.tempStorage = {}; // Initialize temp storage
                this.rosters = this.loadFromStorage();
                this.currentWeek = null;
                this.userName = 'Rohan';
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.cleanOldRosters();
                this.populateWeekSelector();
                this.checkCurrentWeek();
            }

            setupEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const weekSelector = document.getElementById('weekSelector');

                uploadArea.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
                weekSelector.addEventListener('change', (e) => this.displayWeek(e.target.value));

                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragging');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragging');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragging');
                    if (e.dataTransfer.files[0]) {
                        this.processFile(e.dataTransfer.files[0]);
                    }
                });
            }

            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (file && file.type === 'application/pdf') {
                    await this.processFile(file);
                } else {
                    this.showStatus('Please upload a valid PDF file', 'error');
                }
            }

            async processFile(file) {
                this.showLoading();
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                    const page = await pdf.getPage(1);
                    const textContent = await page.getTextContent();
                    
                    const rosterData = this.parseRosterText(textContent);
                    if (rosterData) {
                        this.saveRoster(rosterData);
                        this.populateWeekSelector();
                        this.displayWeek(rosterData.weekEnding);
                        this.showStatus('Roster uploaded successfully', 'success');
                    } else {
                        this.showStatus('Could not find your schedule in this roster', 'error');
                    }
                } catch (error) {
                    console.error('Error processing PDF:', error);
                    this.showStatus('Error processing PDF file', 'error');
                }
            }

            parseRosterText(textContent) {
                const items = textContent.items.map(item => item.str);
                const fullText = items.join(' ');
                
                // Find week ending date
                const weekEndingMatch = fullText.match(/Week ending (\d{2}\/\d{2}\/\d{4})/);
                if (!weekEndingMatch) {
                    console.log('No week ending found');
                    return null;
                }
                const weekEnding = weekEndingMatch[1];
                console.log('Found week ending:', weekEnding);

                // Initialize schedule structure
                const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                const schedule = {};
                
                // Find dates for each day
                const datePattern = /(\d{2}\.\d{2}\.\d{4})/g;
                const dates = fullText.match(datePattern);
                console.log('Found dates:', dates);
                
                if (dates && dates.length >= 5) {
                    days.forEach((day, index) => {
                        schedule[day] = {
                            date: dates[index],
                            shifts: []
                        };
                    });
                }

                // Parse the PDF structure more carefully
                // The PDF has sections like "ATM/ Processing office", "Packer/CP", etc.
                // Each section has time slots and names arranged in columns for each day
                
                const textItems = textContent.items;
                console.log('Total text items:', textItems.length);
                
                // Group items by their y-coordinate (rows) and x-coordinate (columns)
                const rows = {};
                textItems.forEach(item => {
                    const y = Math.round(item.transform[5]); // Y coordinate
                    if (!rows[y]) rows[y] = [];
                    rows[y].push({
                        text: item.str,
                        x: Math.round(item.transform[4]) // X coordinate
                    });
                });

                // Sort rows by Y coordinate (top to bottom)
                const sortedYs = Object.keys(rows).map(Number).sort((a, b) => b - a);
                
                let currentSection = '';
                const sections = [
                    'ATM/ Processing office',
                    'Packer/CP', 
                    'Batching',
                    'ATM/Processing',
                    'Dispatch',
                    'Leave'
                ];

                // Process each row
                for (let y of sortedYs) {
                    const rowItems = rows[y].sort((a, b) => a.x - b.x);
                    const rowText = rowItems.map(item => item.text).join(' ');
                    
                    // Check if this row contains a section header
                    const foundSection = sections.find(section => rowText.includes(section));
                    if (foundSection) {
                        currentSection = foundSection;
                        console.log('Found section:', currentSection);
                        continue;
                    }
                    
                    // Check if this row contains a time slot
                    const timeMatch = rowText.match(/(\d{1,2}:\d{2})-(\d{1,2}:\d{2})/);
                    if (timeMatch && currentSection) {
                        const timeSlot = timeMatch[0];
                        const startTime = timeMatch[1];
                        const endTime = timeMatch[2];
                        console.log('Found time slot:', timeSlot, 'in section:', currentSection);
                        
                        // Look for Rohan in the same row or subsequent rows
                        let foundRohan = false;
                        
                        // Check current row first
                        if (rowText.includes('Rohan')) {
                            foundRohan = true;
                            this.processRohanEntry(rowText, rowItems, schedule, days, startTime, endTime, currentSection);
                        }
                        
                        // If not found in current row, check next few rows for names
                        if (!foundRohan) {
                            const currentYIndex = sortedYs.indexOf(y);
                            for (let i = currentYIndex + 1; i < Math.min(currentYIndex + 10, sortedYs.length); i++) {
                                const nextY = sortedYs[i];
                                const nextRowItems = rows[nextY].sort((a, b) => a.x - b.x);
                                const nextRowText = nextRowItems.map(item => item.text).join(' ');
                                
                                // Stop if we hit another time slot or section
                                if (nextRowText.match(/\d{1,2}:\d{2}-\d{1,2}:\d{2}/) || 
                                    sections.some(section => nextRowText.includes(section))) {
                                    break;
                                }
                                
                                if (nextRowText.includes('Rohan')) {
                                    this.processRohanEntry(nextRowText, nextRowItems, schedule, days, startTime, endTime, currentSection);
                                    break;
                                }
                            }
                        }
                    }
                }

                console.log('Final schedule:', schedule);
                
                // Check if we found any shifts for Rohan
                const hasShifts = days.some(day => schedule[day] && schedule[day].shifts && schedule[day].shifts.length > 0);
                
                if (!hasShifts) {
                    console.log('No shifts found for Rohan, parsing may have failed');
                    return null;
                }

                return {
                    weekEnding,
                    schedule,
                    uploadDate: new Date().toISOString()
                };
            }

            processRohanEntry(rowText, rowItems, schedule, days, startTime, endTime, currentSection) {
                console.log('Processing Rohan entry:', rowText);
                
                // Extract note if present (e.g., "Rohan(ATM)" or "Rohan (ATM)")
                const noteMatch = rowText.match(/Rohan\s*\(([^)]+)\)/);
                const note = noteMatch ? noteMatch[1] : '';
                
                // Find which column(s) Rohan appears in
                // The PDF has day columns, so we need to determine column positions
                const rohanItems = rowItems.filter(item => item.text.includes('Rohan'));
                
                if (rohanItems.length > 0) {
                    // Determine day columns based on x-coordinates
                    // We need to map x-coordinates to days
                    const dayColumns = this.mapColumnsToDays(rowItems);
                    
                    rohanItems.forEach(rohanItem => {
                        const dayIndex = this.getDayFromXCoordinate(rohanItem.x, dayColumns);
                        if (dayIndex >= 0 && dayIndex < days.length) {
                            const day = days[dayIndex];
                            console.log(`Adding shift for ${day}: ${startTime}-${endTime} in ${currentSection}`);
                            
                            schedule[day].shifts.push({
                                startTime: startTime,
                                endTime: endTime,
                                section: currentSection,
                                note: note
                            });
                        }
                    });
                }
            }

            mapColumnsToDays(rowItems) {
                // This function maps x-coordinates to day columns
                // Sort items by x-coordinate to establish column boundaries
                const sortedItems = rowItems.sort((a, b) => a.x - b.x);
                const xCoords = sortedItems.map(item => item.x);
                
                // Find day headers in the document to establish column boundaries
                // For now, we'll use a simple approach assuming 5 equal columns
                const minX = Math.min(...xCoords);
                const maxX = Math.max(...xCoords);
                const columnWidth = (maxX - minX) / 5;
                
                return {
                    minX,
                    maxX,
                    columnWidth
                };
            }

            getDayFromXCoordinate(x, dayColumns) {
                // Determine which day column this x-coordinate belongs to
                const relativeX = x - dayColumns.minX;
                const columnIndex = Math.floor(relativeX / dayColumns.columnWidth);
                return Math.min(Math.max(columnIndex, 0), 4); // Ensure 0-4 range
            }

            findDayColumn(nameLine, allLines, currentIndex) {
                // This function attempts to determine which day column a name appears in
                // by analyzing the position and context
                
                // Look for day headers above this position
                for (let i = currentIndex - 1; i >= Math.max(0, currentIndex - 20); i--) {
                    const line = allLines[i];
                    if (line.includes('Monday')) return 0;
                    if (line.includes('Tuesday')) return 1;
                    if (line.includes('Wednesday')) return 2;
                    if (line.includes('Thursday')) return 3;
                    if (line.includes('Friday')) return 4;
                }
                
                // If we can't determine the column, return -1
                return -1;
            }

            saveRoster(rosterData) {
                this.rosters[rosterData.weekEnding] = rosterData;
                this.saveToStorage();
                console.log('Saved roster for week:', rosterData.weekEnding);
                console.log('Total rosters:', Object.keys(this.rosters).length);
            }

            displayWeek(weekEnding) {
                if (!weekEnding) {
                    this.showEmptyState();
                    return;
                }

                const roster = this.rosters[weekEnding];
                if (!roster) {
                    this.showEmptyState();
                    return;
                }

                const display = document.getElementById('scheduleDisplay');
                const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                
                let html = `
                    <div class="week-info">
                        <h3>Week Ending: ${weekEnding}</h3>
                        <p>Schedule for ${this.userName}</p>
                    </div>
                `;

                days.forEach(day => {
                    const dayData = roster.schedule[day];
                    if (dayData && dayData.shifts && dayData.shifts.length > 0) {
                        const shift = dayData.shifts[0]; // Taking first shift if multiple
                        html += `
                            <div class="day-schedule">
                                <div class="day-label">${day}</div>
                                <div class="time-display">${shift.startTime} - ${shift.endTime}</div>
                                <div class="section-badge">${shift.section}</div>
                                ${shift.note ? `<div class="note-badge">${shift.note}</div>` : ''}
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="day-schedule off-day">
                                <div class="day-label">${day}</div>
                                <div class="time-display">Off</div>
                            </div>
                        `;
                    }
                });

                display.innerHTML = html;
            }

            populateWeekSelector() {
                const selector = document.getElementById('weekSelector');
                const currentWeek = this.getCurrentWeek();
                
                let options = '<option value="">Select a week...</option>';
                
                Object.keys(this.rosters)
                    .sort((a, b) => {
                        const dateA = this.parseWeekEnding(a);
                        const dateB = this.parseWeekEnding(b);
                        return dateB - dateA;
                    })
                    .forEach(weekEnding => {
                        const isCurrentWeek = this.isCurrentWeek(weekEnding);
                        options += `
                            <option value="${weekEnding}">
                                Week ending ${weekEnding}
                                ${isCurrentWeek ? ' (Current Week)' : ''}
                            </option>
                        `;
                    });
                
                selector.innerHTML = options;
                
                // Auto-select current week if available
                if (currentWeek) {
                    selector.value = currentWeek;
                }
            }

            parseWeekEnding(weekEndingStr) {
                const parts = weekEndingStr.split('/');
                return new Date(parts[2], parts[1] - 1, parts[0]);
            }

            isCurrentWeek(weekEnding) {
                const weekEndDate = this.parseWeekEnding(weekEnding);
                const today = new Date();
                const diffTime = weekEndDate - today;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                return diffDays >= 0 && diffDays <= 7;
            }

            getCurrentWeek() {
                const today = new Date();
                const weeks = Object.keys(this.rosters);
                
                for (let weekEnding of weeks) {
                    if (this.isCurrentWeek(weekEnding)) {
                        return weekEnding;
                    }
                }
                return null;
            }

            checkCurrentWeek() {
                const currentWeek = this.getCurrentWeek();
                if (currentWeek) {
                    document.getElementById('weekSelector').value = currentWeek;
                    this.displayWeek(currentWeek);
                }
            }

            cleanOldRosters() {
                const fiveWeeksAgo = new Date();
                fiveWeeksAgo.setDate(fiveWeeksAgo.getDate() - 35);
                
                Object.keys(this.rosters).forEach(weekEnding => {
                    const rosterDate = this.parseWeekEnding(weekEnding);
                    if (rosterDate < fiveWeeksAgo) {
                        delete this.rosters[weekEnding];
                    }
                });
                
                this.saveToStorage();
            }

            showEmptyState() {
                document.getElementById('scheduleDisplay').innerHTML = `
                    <div class="empty-state">
                        <h3>No roster selected</h3>
                        <p>Upload a PDF roster or select a week from the dropdown to view your schedule</p>
                    </div>
                `;
            }

            showLoading() {
                document.getElementById('scheduleDisplay').innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Processing roster...</p>
                    </div>
                `;
            }

            showStatus(message, type) {
                const statusEl = document.getElementById('statusMessage');
                statusEl.textContent = message;
                statusEl.className = `status-message ${type}`;
                
                setTimeout(() => {
                    statusEl.className = 'status-message';
                }, 3000);
            }

            saveToStorage() {
                // Using in-memory storage only since localStorage is not supported
                // Data will persist during the session
                this.tempStorage = { ...this.rosters };
            }

            loadFromStorage() {
                // Return existing temp storage or empty object
                return this.tempStorage || {};
            }
        }

        // Initialize the app
        const app = new RosterTracker();
    </script>
</body>
</html>
